/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

interface ExceptionWithCode {
	code: string | number;
	name?: string;
	message?: string;
	stack?: string;
}
interface ExceptionWithMessage {
	code?: string | number;
	message: string;
	name?: string;
	stack?: string;
}
interface ExceptionWithName {
	code?: string | number;
	message?: string;
	name: string;
	stack?: string;
}
/**
 * Defines Exception.
 *
 * string or an object with one of (message or name or code) and optional stack
 *
 * @since 1.0.0
 */
type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;

/**
 * Defines High-Resolution Time.
 *
 * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.
 * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.
 * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.
 * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:
 * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.
 * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:
 * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.
 * This is represented in HrTime format as [1609504210, 150000000].
 *
 * @since 1.0.0
 */
type HrTime = [number, number];
/**
 * Defines TimeInput.
 *
 * hrtime, epoch milliseconds, performance.now() or Date
 *
 * @since 1.0.0
 */
type TimeInput = HrTime | number | Date;

/**
 * Attributes is a map from string to attribute values.
 *
 * Note: only the own enumerable keys are counted as valid attribute keys.
 *
 * @since 1.3.0
 */
interface Attributes {
	[attributeKey: string]: AttributeValue | undefined;
}
/**
 * Attribute values may be any non-nullish primitive value except an object.
 *
 * null or undefined attribute values are invalid and will result in undefined behavior.
 *
 * @since 1.3.0
 */
type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;

/**
 * @deprecated please use {@link Attributes}
 * @since 1.0.0
 */
type SpanAttributes = Attributes;
/**
 * @deprecated please use {@link AttributeValue}
 * @since 1.0.0
 */
type SpanAttributeValue = AttributeValue;

/**
 * @since 1.0.0
 */
interface TraceState {
	/**
	* Create a new TraceState which inherits from this TraceState and has the
	* given key set.
	* The new entry will always be added in the front of the list of states.
	*
	* @param key key of the TraceState entry.
	* @param value value of the TraceState entry.
	*/
	set(key: string, value: string): TraceState;
	/**
	* Return a new TraceState which inherits from this TraceState but does not
	* contain the given key.
	*
	* @param key the key for the TraceState entry to be removed.
	*/
	unset(key: string): TraceState;
	/**
	* Returns the value to which the specified key is mapped, or `undefined` if
	* this map contains no mapping for the key.
	*
	* @param key with which the specified value is to be associated.
	* @returns the value to which the specified key is mapped, or `undefined` if
	*     this map contains no mapping for the key.
	*/
	get(key: string): string | undefined;
	/**
	* Serializes the TraceState to a `list` as defined below. The `list` is a
	* series of `list-members` separated by commas `,`, and a list-member is a
	* key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
	* surrounding `list-members` are ignored. There can be a maximum of 32
	* `list-members` in a `list`.
	*
	* @returns the serialized string.
	*/
	serialize(): string;
}

/**
 * A SpanContext represents the portion of a {@link Span} which must be
 * serialized and propagated along side of a {@link Baggage}.
 *
 * @since 1.0.0
 */
interface SpanContext {
	/**
	* The ID of the trace that this span belongs to. It is worldwide unique
	* with practically sufficient probability by being made as 16 randomly
	* generated bytes, encoded as a 32 lowercase hex characters corresponding to
	* 128 bits.
	*/
	traceId: string;
	/**
	* The ID of the Span. It is globally unique with practically sufficient
	* probability by being made as 8 randomly generated bytes, encoded as a 16
	* lowercase hex characters corresponding to 64 bits.
	*/
	spanId: string;
	/**
	* Only true if the SpanContext was propagated from a remote parent.
	*/
	isRemote?: boolean;
	/**
	* Trace flags to propagate.
	*
	* It is represented as 1 byte (bitmap). Bit to represent whether trace is
	* sampled or not. When set, the least significant bit documents that the
	* caller may have recorded trace data. A caller who does not record trace
	* data out-of-band leaves this flag unset.
	*
	* see {@link TraceFlags} for valid flag values.
	*/
	traceFlags: number;
	/**
	* Tracing-system-specific info to propagate.
	*
	* The tracestate field value is a `list` as defined below. The `list` is a
	* series of `list-members` separated by commas `,`, and a list-member is a
	* key/value pair separated by an equals sign `=`. Spaces and horizontal tabs
	* surrounding `list-members` are ignored. There can be a maximum of 32
	* `list-members` in a `list`.
	* More Info: https://www.w3.org/TR/trace-context/#tracestate-field
	*
	* Examples:
	*     Single tracing system (generic format):
	*         tracestate: rojo=00f067aa0ba902b7
	*     Multiple tracing systems (with different formatting):
	*         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
	*/
	traceState?: TraceState;
}

/**
 * @since 1.0.0
 */
interface SpanStatus {
	/** The status code of this message. */
	code: SpanStatusCode;
	/** A developer-facing error message. */
	message?: string;
}
/**
 * An enumeration of status codes.
 *
 * @since 1.0.0
 */
declare enum SpanStatusCode {
	/**
	* The default status.
	*/
	UNSET = 0,
	/**
	* The operation has been validated by an Application developer or
	* Operator to have completed successfully.
	*/
	OK = 1,
	/**
	* The operation contains an error.
	*/
	ERROR = 2
}

/**
 * A pointer from the current {@link Span} to another span in the same trace or
 * in a different trace.
 * Few examples of Link usage.
 * 1. Batch Processing: A batch of elements may contain elements associated
 *    with one or more traces/spans. Since there can only be one parent
 *    SpanContext, Link is used to keep reference to SpanContext of all
 *    elements in the batch.
 * 2. Public Endpoint: A SpanContext in incoming client request on a public
 *    endpoint is untrusted from service provider perspective. In such case it
 *    is advisable to start a new trace with appropriate sampling decision.
 *    However, it is desirable to associate incoming SpanContext to new trace
 *    initiated on service provider side so two traces (from Client and from
 *    Service Provider) can be correlated.
 *
 * @since 1.0.0
 */
interface Link {
	/** The {@link SpanContext} of a linked span. */
	context: SpanContext;
	/** A set of {@link SpanAttributes} on the link. */
	attributes?: SpanAttributes;
	/** Count of attributes of the link that were dropped due to collection limits */
	droppedAttributesCount?: number;
}

/**
 * An interface that represents a span. A span represents a single operation
 * within a trace. Examples of span might include remote procedure calls or a
 * in-process function calls to sub-components. A Trace has a single, top-level
 * "root" Span that in turn may have zero or more child Spans, which in turn
 * may have children.
 *
 * Spans are created by the {@link Tracer.startSpan} method.
 *
 * @since 1.0.0
 */
interface Span {
	/**
	* Returns the {@link SpanContext} object associated with this Span.
	*
	* Get an immutable, serializable identifier for this span that can be used
	* to create new child spans. Returned SpanContext is usable even after the
	* span ends.
	*
	* @returns the SpanContext object associated with this Span.
	*/
	spanContext(): SpanContext;
	/**
	* Sets an attribute to the span.
	*
	* Sets a single Attribute with the key and value passed as arguments.
	*
	* @param key the key for this attribute.
	* @param value the value for this attribute. Setting a value null or
	*              undefined is invalid and will result in undefined behavior.
	*/
	setAttribute(key: string, value: SpanAttributeValue): this;
	/**
	* Sets attributes to the span.
	*
	* @param attributes the attributes that will be added.
	*                   null or undefined attribute values
	*                   are invalid and will result in undefined behavior.
	*/
	setAttributes(attributes: SpanAttributes): this;
	/**
	* Adds an event to the Span.
	*
	* @param name the name of the event.
	* @param [attributesOrStartTime] the attributes that will be added; these are
	*     associated with this event. Can be also a start time
	*     if type is {@type TimeInput} and 3rd param is undefined
	* @param [startTime] start time of the event.
	*/
	addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;
	/**
	* Adds a single link to the span.
	*
	* Links added after the creation will not affect the sampling decision.
	* It is preferred span links be added at span creation.
	*
	* @param link the link to add.
	*/
	addLink(link: Link): this;
	/**
	* Adds multiple links to the span.
	*
	* Links added after the creation will not affect the sampling decision.
	* It is preferred span links be added at span creation.
	*
	* @param links the links to add.
	*/
	addLinks(links: Link[]): this;
	/**
	* Sets a status to the span. If used, this will override the default Span
	* status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value
	* of previous calls to SetStatus on the Span.
	*
	* @param status the SpanStatus to set.
	*/
	setStatus(status: SpanStatus): this;
	/**
	* Updates the Span name.
	*
	* This will override the name provided via {@link Tracer.startSpan}.
	*
	* Upon this update, any sampling behavior based on Span name will depend on
	* the implementation.
	*
	* @param name the Span name.
	*/
	updateName(name: string): this;
	/**
	* Marks the end of Span execution.
	*
	* Call to End of a Span MUST not have any effects on child spans. Those may
	* still be running and can be ended later.
	*
	* Do not return `this`. The Span generally should not be used after it
	* is ended so chaining is not desired in this context.
	*
	* @param [endTime] the time to set as Span's end time. If not provided,
	*     use the current time as the span's end time.
	*/
	end(endTime?: TimeInput): void;
	/**
	* Returns the flag whether this span will be recorded.
	*
	* @returns true if this Span is active and recording information like events
	*     with the `AddEvent` operation and attributes using `setAttributes`.
	*/
	isRecording(): boolean;
	/**
	* Sets exception as a span event
	* @param exception the exception the only accepted values are string or Error
	* @param [time] the time to set as Span's event time. If not provided,
	*     use the current time.
	*/
	recordException(exception: Exception, time?: TimeInput): void;
}

/**
 * @since 1.0.0
 */
declare function isValidTraceId(traceId: string): boolean;
/**
 * @since 1.0.0
 */
declare function isValidSpanId(spanId: string): boolean;
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 *
 * @since 1.0.0
 */
declare function isSpanContextValid(spanContext: SpanContext): boolean;
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
declare function wrapSpanContext(spanContext: SpanContext): Span;

/**
 * @since 1.0.0
 */
interface Context {
	/**
	* Get a value from the context.
	*
	* @param key key which identifies a context value
	*/
	getValue(key: symbol): unknown;
	/**
	* Create a new context which inherits from this context and has
	* the given key set to the given value.
	*
	* @param key context key for which to set the value
	* @param value value to set for the given key
	*/
	setValue(key: symbol, value: unknown): Context;
	/**
	* Return a new context which inherits from this context but does
	* not contain a value for the given key.
	*
	* @param key context key for which to clear a value
	*/
	deleteValue(key: symbol): Context;
}
/**
 * @since 1.0.0
 */
interface ContextManager {
	/**
	* Get the current active context
	*/
	active(): Context;
	/**
	* Run the fn callback with object set as the current active context
	* @param context Any object to set as the current active context
	* @param fn A callback to be immediately run within a specific context
	* @param thisArg optional receiver to be used for calling fn
	* @param args optional arguments forwarded to fn
	*/
	with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(context: Context, fn: F, thisArg?: ThisParameterType<F>, ...args: A): ReturnType<F>;
	/**
	* Bind an object as the current context (or a specific one)
	* @param [context] Optionally specify the context which you want to assign
	* @param target Any object to which a context need to be set
	*/
	bind<T>(context: Context, target: T): T;
	/**
	* Enable context management
	*/
	enable(): this;
	/**
	* Disable context management
	*/
	disable(): this;
}

/**
 * @since 1.0.0
 */
declare enum SpanKind {
	/** Default value. Indicates that the span is used internally. */
	INTERNAL = 0,
	/**
	* Indicates that the span covers server-side handling of an RPC or other
	* remote request.
	*/
	SERVER = 1,
	/**
	* Indicates that the span covers the client-side wrapper around an RPC or
	* other remote request.
	*/
	CLIENT = 2,
	/**
	* Indicates that the span describes producer sending a message to a
	* broker. Unlike client and server, there is no direct critical path latency
	* relationship between producer and consumer spans.
	*/
	PRODUCER = 3,
	/**
	* Indicates that the span describes consumer receiving a message from a
	* broker. Unlike client and server, there is no direct critical path latency
	* relationship between producer and consumer spans.
	*/
	CONSUMER = 4
}

/**
 * Options needed for span creation
 *
 * @since 1.0.0
 */
interface SpanOptions {
	/**
	* The SpanKind of a span
	* @default {@link SpanKind.INTERNAL}
	*/
	kind?: SpanKind;
	/** A span's attributes */
	attributes?: SpanAttributes;
	/** {@link Link}s span to other spans */
	links?: Link[];
	/** A manually specified start time for the created `Span` object. */
	startTime?: TimeInput;
	/** The new span should be a root span. (Ignore parent from context). */
	root?: boolean;
}

/**
 * Tracer provides an interface for creating {@link Span}s.
 *
 * @since 1.0.0
 */
interface Tracer {
	/**
	* Starts a new {@link Span}. Start the span without setting it on context.
	*
	* This method do NOT modify the current Context.
	*
	* @param name The name of the span
	* @param [options] SpanOptions used for span creation
	* @param [context] Context to use to extract parent
	* @returns Span The newly created span
	* @example
	*     const span = tracer.startSpan('op');
	*     span.setAttribute('key', 'value');
	*     span.end();
	*/
	startSpan(name: string, options?: SpanOptions, context?: Context): Span;
	/**
	* Starts a new {@link Span} and calls the given function passing it the
	* created span as first argument.
	* Additionally the new span gets set in context and this context is activated
	* for the duration of the function call.
	*
	* @param name The name of the span
	* @param [options] SpanOptions used for span creation
	* @param [context] Context to use to extract parent
	* @param fn function called in the context of the span and receives the newly created span as an argument
	* @returns return value of fn
	* @example
	*     const something = tracer.startActiveSpan('op', span => {
	*       try {
	*         do some work
	*         span.setStatus({code: SpanStatusCode.OK});
	*         return something;
	*       } catch (err) {
	*         span.setStatus({
	*           code: SpanStatusCode.ERROR,
	*           message: err.message,
	*         });
	*         throw err;
	*       } finally {
	*         span.end();
	*       }
	*     });
	*
	* @example
	*     const span = tracer.startActiveSpan('op', span => {
	*       try {
	*         do some work
	*         return span;
	*       } catch (err) {
	*         span.setStatus({
	*           code: SpanStatusCode.ERROR,
	*           message: err.message,
	*         });
	*         throw err;
	*       }
	*     });
	*     do some more work
	*     span.end();
	*/
	startActiveSpan<F extends (span: Span) => unknown>(name: string, fn: F): ReturnType<F>;
	startActiveSpan<F extends (span: Span) => unknown>(name: string, options: SpanOptions, fn: F): ReturnType<F>;
	startActiveSpan<F extends (span: Span) => unknown>(name: string, options: SpanOptions, context: Context, fn: F): ReturnType<F>;
}

/**
 * An interface describes additional metadata of a tracer.
 *
 * @since 1.3.0
 */
interface TracerOptions {
	/**
	* The schemaUrl of the tracer or instrumentation library
	*/
	schemaUrl?: string;
}

/**
 * A registry for creating named {@link Tracer}s.
 *
 * @since 1.0.0
 */
interface TracerProvider {
	/**
	* Returns a Tracer, creating one if one with the given name and version is
	* not already created.
	*
	* This function may return different Tracer types (e.g.
	* {@link NoopTracerProvider} vs. a functional tracer).
	*
	* @param name The name of the tracer or instrumentation library.
	* @param version The version of the tracer or instrumentation library.
	* @param options The options of the tracer or instrumentation library.
	* @returns Tracer A Tracer with the given name and version
	*/
	getTracer(name: string, version?: string, options?: TracerOptions): Tracer;
}

/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
declare function getSpan(context: Context): Span | undefined;
/**
 * Gets the span from the current context, if one exists.
 */
declare function getActiveSpan(): Span | undefined;
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
declare function setSpan(context: Context, span: Span): Context;
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
declare function deleteSpan(context: Context): Context;
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
declare function setSpanContext(context: Context, spanContext: SpanContext): Context;
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
declare function getSpanContext(context: Context): SpanContext | undefined;

/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 *
 * @since 1.0.0
 */
declare class TraceAPI {
	private static _instance?;
	private _proxyTracerProvider;
	/** Empty private constructor prevents end users from constructing a new instance of the API */
	private constructor();
	/** Get the singleton instance of the Trace API */
	static getInstance(): TraceAPI;
	/**
	* Set the current global tracer.
	*
	* @returns true if the tracer provider was successfully registered, else false
	*/
	setGlobalTracerProvider(provider: TracerProvider): boolean;
	/**
	* Returns the global tracer provider.
	*/
	getTracerProvider(): TracerProvider;
	/**
	* Returns a tracer from the global tracer provider.
	*/
	getTracer(name: string, version?: string): Tracer;
	/** Remove the global tracer provider */
	disable(): void;
	wrapSpanContext: typeof wrapSpanContext;
	isSpanContextValid: typeof isSpanContextValid;
	deleteSpan: typeof deleteSpan;
	getSpan: typeof getSpan;
	getActiveSpan: typeof getActiveSpan;
	getSpanContext: typeof getSpanContext;
	setSpan: typeof setSpan;
	setSpanContext: typeof setSpanContext;
}

/**
 * Injects `Context` into and extracts it from carriers that travel
 * in-band across process boundaries. Encoding is expected to conform to the
 * HTTP Header Field semantics. Values are often encoded as RPC/HTTP request
 * headers.
 *
 * The carrier of propagated data on both the client (injector) and server
 * (extractor) side is usually an object such as http headers. Propagation is
 * usually implemented via library-specific request interceptors, where the
 * client-side injects values and the server-side extracts them.
 *
 * @since 1.0.0
 */
interface TextMapPropagator<Carrier = any> {
	/**
	* Injects values from a given `Context` into a carrier.
	*
	* OpenTelemetry defines a common set of format values (TextMapPropagator),
	* and each has an expected `carrier` type.
	*
	* @param context the Context from which to extract values to transmit over
	*     the wire.
	* @param carrier the carrier of propagation fields, such as http request
	*     headers.
	* @param setter an optional {@link TextMapSetter}. If undefined, values will be
	*     set by direct object assignment.
	*/
	inject(context: Context, carrier: Carrier, setter: TextMapSetter<Carrier>): void;
	/**
	* Given a `Context` and a carrier, extract context values from a
	* carrier and return a new context, created from the old context, with the
	* extracted values.
	*
	* @param context the Context from which to extract values to transmit over
	*     the wire.
	* @param carrier the carrier of propagation fields, such as http request
	*     headers.
	* @param getter an optional {@link TextMapGetter}. If undefined, keys will be all
	*     own properties, and keys will be accessed by direct object access.
	*/
	extract(context: Context, carrier: Carrier, getter: TextMapGetter<Carrier>): Context;
	/**
	* Return a list of all fields which may be used by the propagator.
	*/
	fields(): string[];
}
/**
 * A setter is specified by the caller to define a specific method
 * to set key/value pairs on the carrier within a propagator
 *
 * @since 1.0.0
 */
interface TextMapSetter<Carrier = any> {
	/**
	* Callback used to set a key/value pair on an object.
	*
	* Should be called by the propagator each time a key/value pair
	* should be set, and should set that key/value pair on the propagator.
	*
	* @param carrier object or class which carries key/value pairs
	* @param key string key to modify
	* @param value value to be set to the key on the carrier
	*/
	set(carrier: Carrier, key: string, value: string): void;
}
/**
 * A getter is specified by the caller to define a specific method
 * to get the value of a key from a carrier.
 *
 * @since 1.0.0
 */
interface TextMapGetter<Carrier = any> {
	/**
	* Get a list of all keys available on the carrier.
	*
	* @param carrier
	*/
	keys(carrier: Carrier): string[];
	/**
	* Get the value of a specific key from the carrier.
	*
	* @param carrier
	* @param key
	*/
	get(carrier: Carrier, key: string): undefined | string | string[];
}
/**
 * @since 1.0.0
 */
declare const defaultTextMapGetter: TextMapGetter;
/**
 * @since 1.0.0
 */
declare const defaultTextMapSetter: TextMapSetter;

/**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */
declare const baggageEntryMetadataSymbol: unique symbol;

/**
 * @since 1.0.0
 */
interface BaggageEntry {
	/** `String` value of the `BaggageEntry`. */
	value: string;
	/**
	* Metadata is an optional string property defined by the W3C baggage specification.
	* It currently has no special meaning defined by the specification.
	*/
	metadata?: BaggageEntryMetadata;
}
/**
 * Serializable Metadata defined by the W3C baggage specification.
 * It currently has no special meaning defined by the OpenTelemetry or W3C.
 *
 * @since 1.0.0
 */
type BaggageEntryMetadata = {
	toString(): string;
} & {
	__TYPE__: typeof baggageEntryMetadataSymbol;
};
/**
 * Baggage represents collection of key-value pairs with optional metadata.
 * Each key of Baggage is associated with exactly one value.
 * Baggage may be used to annotate and enrich telemetry data.
 *
 * @since 1.0.0
 */
interface Baggage {
	/**
	* Get an entry from Baggage if it exists
	*
	* @param key The key which identifies the BaggageEntry
	*/
	getEntry(key: string): BaggageEntry | undefined;
	/**
	* Get a list of all entries in the Baggage
	*/
	getAllEntries(): [string, BaggageEntry][];
	/**
	* Returns a new baggage with the entries from the current bag and the specified entry
	*
	* @param key string which identifies the baggage entry
	* @param entry BaggageEntry for the given key
	*/
	setEntry(key: string, entry: BaggageEntry): Baggage;
	/**
	* Returns a new baggage with the entries from the current bag except the removed entry
	*
	* @param key key identifying the entry to be removed
	*/
	removeEntry(key: string): Baggage;
	/**
	* Returns a new baggage with the entries from the current bag except the removed entries
	*
	* @param key keys identifying the entries to be removed
	*/
	removeEntries(...key: string[]): Baggage;
	/**
	* Returns a new baggage with no entries
	*/
	clear(): Baggage;
}

/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
declare function getBaggage(context: Context): Baggage | undefined;
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */
declare function getActiveBaggage(): Baggage | undefined;
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
declare function setBaggage(context: Context, baggage: Baggage): Context;
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
declare function deleteBaggage(context: Context): Context;

/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
declare function createBaggage(entries?: Record<string, BaggageEntry>): Baggage;
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 * @since 1.0.0
 */
declare function baggageEntryMetadataFromString(str: string): BaggageEntryMetadata;

/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 *
 * @since 1.0.0
 */
declare class PropagationAPI {
	private static _instance?;
	/** Empty private constructor prevents end users from constructing a new instance of the API */
	private constructor();
	/** Get the singleton instance of the Propagator API */
	static getInstance(): PropagationAPI;
	/**
	* Set the current propagator.
	*
	* @returns true if the propagator was successfully registered, else false
	*/
	setGlobalPropagator(propagator: TextMapPropagator): boolean;
	/**
	* Inject context into a carrier to be propagated inter-process
	*
	* @param context Context carrying tracing data to inject
	* @param carrier carrier to inject context into
	* @param setter Function used to set values on the carrier
	*/
	inject<Carrier>(context: Context, carrier: Carrier, setter?: TextMapSetter<Carrier>): void;
	/**
	* Extract context from a carrier
	*
	* @param context Context which the newly created context will inherit from
	* @param carrier Carrier to extract context from
	* @param getter Function used to extract keys from a carrier
	*/
	extract<Carrier>(context: Context, carrier: Carrier, getter?: TextMapGetter<Carrier>): Context;
	/**
	* Return a list of all fields which may be used by the propagator.
	*/
	fields(): string[];
	/** Remove the global propagator */
	disable(): void;
	createBaggage: typeof createBaggage;
	getBaggage: typeof getBaggage;
	getActiveBaggage: typeof getActiveBaggage;
	setBaggage: typeof setBaggage;
	deleteBaggage: typeof deleteBaggage;
	private _getGlobalPropagator;
}

/**
 * Interface that is being used in callback function for Observable Metric.
 *
 * @since 1.3.0
 */
interface ObservableResult<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Observe a measurement of the value associated with the given attributes.
	*
	* @param value The value to be observed.
	* @param attributes The attributes associated with the value. If more than
	* one values associated with the same attributes values, SDK may pick the
	* last one or simply drop the entire observable result.
	*/
	observe(this: ObservableResult<AttributesTypes>, value: number, attributes?: AttributesTypes): void;
}
/**
 * Interface that is being used in batch observable callback function.
 */
interface BatchObservableResult<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Observe a measurement of the value associated with the given attributes.
	*
	* @param metric The observable metric to be observed.
	* @param value The value to be observed.
	* @param attributes The attributes associated with the value. If more than
	* one values associated with the same attributes values, SDK may pick the
	* last one or simply drop the entire observable result.
	*/
	observe(this: BatchObservableResult<AttributesTypes>, metric: Observable<AttributesTypes>, value: number, attributes?: AttributesTypes): void;
}

/**
 * Advisory options influencing aggregation configuration parameters.
 *
 * @since 1.7.0
 * @experimental
 */
interface MetricAdvice {
	/**
	* Hint the explicit bucket boundaries for SDK if the metric is been
	* aggregated with a HistogramAggregator.
	*/
	explicitBucketBoundaries?: number[];
}
/**
 * Options needed for metric creation
 *
 * @since 1.3.0
 */
interface MetricOptions {
	/**
	* The description of the Metric.
	* @default ''
	*/
	description?: string;
	/**
	* The unit of the Metric values.
	* @default ''
	*/
	unit?: string;
	/**
	* Indicates the type of the recorded value.
	* @default {@link ValueType.DOUBLE}
	*/
	valueType?: ValueType;
	/**
	* The advice influencing aggregation configuration parameters.
	* @experimental
	* @since 1.7.0
	*/
	advice?: MetricAdvice;
}
/**
 * The Type of value. It describes how the data is reported.
 *
 * @since 1.3.0
 */
declare enum ValueType {
	INT = 0,
	DOUBLE = 1
}
/**
 * Counter is the most common synchronous instrument. This instrument supports
 * an `Add(increment)` function for reporting a sum, and is restricted to
 * non-negative increments. The default aggregation is Sum, as for any additive
 * instrument.
 *
 * Example uses for Counter:
 * <ol>
 *   <li> count the number of bytes received. </li>
 *   <li> count the number of requests completed. </li>
 *   <li> count the number of accounts created. </li>
 *   <li> count the number of checkpoints run. </li>
 *   <li> count the number of 5xx errors. </li>
 * <ol>
 *
 * @since 1.3.0
 */
interface Counter<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Increment value of counter by the input. Inputs must not be negative.
	*/
	add(value: number, attributes?: AttributesTypes, context?: Context): void;
}
/**
 * @since 1.3.0
 */
interface UpDownCounter<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Increment value of counter by the input. Inputs may be negative.
	*/
	add(value: number, attributes?: AttributesTypes, context?: Context): void;
}
/**
 * @since 1.9.0
 */
interface Gauge<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Records a measurement.
	*/
	record(value: number, attributes?: AttributesTypes, context?: Context): void;
}
/**
 * @since 1.3.0
 */
interface Histogram<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Records a measurement. Value of the measurement must not be negative.
	*/
	record(value: number, attributes?: AttributesTypes, context?: Context): void;
}
/**
 * @deprecated please use {@link Attributes}
 * @since 1.3.0
 */
type MetricAttributes = Attributes;
/**
 * @deprecated please use {@link AttributeValue}
 * @since 1.3.0
 */
type MetricAttributeValue = AttributeValue;
/**
 * The observable callback for Observable instruments.
 *
 * @since 1.3.0
 */
type ObservableCallback<AttributesTypes extends MetricAttributes = MetricAttributes> = (observableResult: ObservableResult<AttributesTypes>) => void | Promise<void>;
/**
 * The observable callback for a batch of Observable instruments.
 *
 * @since 1.3.0
 */
type BatchObservableCallback<AttributesTypes extends MetricAttributes = MetricAttributes> = (observableResult: BatchObservableResult<AttributesTypes>) => void | Promise<void>;
/**
 * @since 1.3.0
 */
interface Observable<AttributesTypes extends MetricAttributes = MetricAttributes> {
	/**
	* Sets up a function that will be called whenever a metric collection is initiated.
	*
	* If the function is already in the list of callbacks for this Observable, the function is not added a second time.
	*/
	addCallback(callback: ObservableCallback<AttributesTypes>): void;
	/**
	* Removes a callback previously registered with {@link Observable.addCallback}.
	*/
	removeCallback(callback: ObservableCallback<AttributesTypes>): void;
}
/**
 * @since 1.3.0
 */
type ObservableCounter<AttributesTypes extends MetricAttributes = MetricAttributes> = Observable<AttributesTypes>;
/**
 * @since 1.3.0
 */
type ObservableUpDownCounter<AttributesTypes extends MetricAttributes = MetricAttributes> = Observable<AttributesTypes>;
/**
 * @since 1.3.0
 */
type ObservableGauge<AttributesTypes extends MetricAttributes = MetricAttributes> = Observable<AttributesTypes>;

/**
 * An interface describes additional metadata of a meter.
 *
 * @since 1.3.0
 */
interface MeterOptions {
	/**
	* The schemaUrl of the meter or instrumentation library
	*/
	schemaUrl?: string;
}
/**
 * An interface to allow the recording metrics.
 *
 * {@link Metric}s are used for recording pre-defined aggregation (`Counter`),
 * or raw values (`Histogram`) in which the aggregation and attributes
 * for the exported metric are deferred.
 *
 * @since 1.3.0
 */
interface Meter {
	/**
	* Creates and returns a new `Gauge`.
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createGauge<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): Gauge<AttributesTypes>;
	/**
	* Creates and returns a new `Histogram`.
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createHistogram<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): Histogram<AttributesTypes>;
	/**
	* Creates a new `Counter` metric. Generally, this kind of metric when the
	* value is a quantity, the sum is of primary interest, and the event count
	* and value distribution are not of primary interest.
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createCounter<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): Counter<AttributesTypes>;
	/**
	* Creates a new `UpDownCounter` metric. UpDownCounter is a synchronous
	* instrument and very similar to Counter except that Add(increment)
	* supports negative increments. It is generally useful for capturing changes
	* in an amount of resources used, or any quantity that rises and falls
	* during a request.
	* Example uses for UpDownCounter:
	* <ol>
	*   <li> count the number of active requests. </li>
	*   <li> count memory in use by instrumenting new and delete. </li>
	*   <li> count queue size by instrumenting enqueue and dequeue. </li>
	*   <li> count semaphore up and down operations. </li>
	* </ol>
	*
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createUpDownCounter<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): UpDownCounter<AttributesTypes>;
	/**
	* Creates a new `ObservableGauge` metric.
	*
	* The callback SHOULD be safe to be invoked concurrently.
	*
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createObservableGauge<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): ObservableGauge<AttributesTypes>;
	/**
	* Creates a new `ObservableCounter` metric.
	*
	* The callback SHOULD be safe to be invoked concurrently.
	*
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createObservableCounter<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): ObservableCounter<AttributesTypes>;
	/**
	* Creates a new `ObservableUpDownCounter` metric.
	*
	* The callback SHOULD be safe to be invoked concurrently.
	*
	* @param name the name of the metric.
	* @param [options] the metric options.
	*/
	createObservableUpDownCounter<AttributesTypes extends MetricAttributes = MetricAttributes>(name: string, options?: MetricOptions): ObservableUpDownCounter<AttributesTypes>;
	/**
	* Sets up a function that will be called whenever a metric collection is
	* initiated.
	*
	* If the function is already in the list of callbacks for this Observable,
	* the function is not added a second time.
	*
	* Only the associated observables can be observed in the callback.
	* Measurements of observables that are not associated observed in the
	* callback are dropped.
	*
	* @param callback the batch observable callback
	* @param observables the observables associated with this batch observable callback
	*/
	addBatchObservableCallback<AttributesTypes extends MetricAttributes = MetricAttributes>(callback: BatchObservableCallback<AttributesTypes>, observables: Observable<AttributesTypes>[]): void;
	/**
	* Removes a callback previously registered with {@link Meter.addBatchObservableCallback}.
	*
	* The callback to be removed is identified using a combination of the callback itself,
	* and the set of the observables associated with it.
	*
	* @param callback the batch observable callback
	* @param observables the observables associated with this batch observable callback
	*/
	removeBatchObservableCallback<AttributesTypes extends MetricAttributes = MetricAttributes>(callback: BatchObservableCallback<AttributesTypes>, observables: Observable<AttributesTypes>[]): void;
}

/**
 * A registry for creating named {@link Meter}s.
 *
 * @since 1.3.0
 */
interface MeterProvider {
	/**
	* Returns a Meter, creating one if one with the given name, version, and
	* schemaUrl pair is not already created.
	*
	* @param name The name of the meter or instrumentation library.
	* @param version The version of the meter or instrumentation library.
	* @param options The options of the meter or instrumentation library.
	* @returns Meter A Meter with the given name and version
	*/
	getMeter(name: string, version?: string, options?: MeterOptions): Meter;
}

/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */
declare class MetricsAPI {
	private static _instance?;
	/** Empty private constructor prevents end users from constructing a new instance of the API */
	private constructor();
	/** Get the singleton instance of the Metrics API */
	static getInstance(): MetricsAPI;
	/**
	* Set the current global meter provider.
	* Returns true if the meter provider was successfully registered, else false.
	*/
	setGlobalMeterProvider(provider: MeterProvider): boolean;
	/**
	* Returns the global meter provider.
	*/
	getMeterProvider(): MeterProvider;
	/**
	* Returns a meter from the global meter provider.
	*/
	getMeter(name: string, version?: string, options?: MeterOptions): Meter;
	/** Remove the global meter provider */
	disable(): void;
}

/**
 * @since 1.0.0
 */
type DiagLogFunction = (message: string, ...args: unknown[]) => void;
/**
 * Defines an internal diagnostic logger interface which is used to log internal diagnostic
 * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.
 * API provided implementations include :-
 * - a No-Op {@link createNoopDiagLogger}
 * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}
 * - a general Console {@link DiagConsoleLogger} version.
 *
 * @since 1.0.0
 */
interface DiagLogger {
	/** Log an error scenario that was not expected and caused the requested operation to fail. */
	error: DiagLogFunction;
	/**
	* Log a warning scenario to inform the developer of an issues that should be investigated.
	* The requested operation may or may not have succeeded or completed.
	*/
	warn: DiagLogFunction;
	/**
	* Log a general informational message, this should not affect functionality.
	* This is also the default logging level so this should NOT be used for logging
	* debugging level information.
	*/
	info: DiagLogFunction;
	/**
	* Log a general debug message that can be useful for identifying a failure.
	* Information logged at this level may include diagnostic details that would
	* help identify a failure scenario.
	* For example: Logging the order of execution of async operations.
	*/
	debug: DiagLogFunction;
	/**
	* Log a detailed (verbose) trace level logging that can be used to identify failures
	* where debug level logging would be insufficient, this level of tracing can include
	* input and output parameters and as such may include PII information passing through
	* the API. As such it is recommended that this level of tracing should not be enabled
	* in a production environment.
	*/
	verbose: DiagLogFunction;
}
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
declare enum DiagLogLevel {
	/** Diagnostic Logging level setting to disable all logging (except and forced logs) */
	NONE = 0,
	/** Identifies an error scenario */
	ERROR = 30,
	/** Identifies a warning scenario */
	WARN = 50,
	/** General informational log message */
	INFO = 60,
	/** General debug log message */
	DEBUG = 70,
	/**
	* Detailed trace level logging should only be used for development, should only be set
	* in a development environment.
	*/
	VERBOSE = 80,
	/** Used to set the logging level to include all logging */
	ALL = 9999
}
/**
 * Defines options for ComponentLogger
 *
 * @since 1.0.0
 */
interface ComponentLoggerOptions {
	namespace: string;
}
/**
 * @since 1.4.1
 */
interface DiagLoggerOptions {
	/**
	* The {@link DiagLogLevel} used to filter logs sent to the logger.
	*
	* @defaultValue DiagLogLevel.INFO
	*/
	logLevel?: DiagLogLevel;
	/**
	* Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.
	*/
	suppressOverrideMessage?: boolean;
}
interface DiagLoggerApi {
	/**
	* Set the global DiagLogger and DiagLogLevel.
	* If a global diag logger is already set, this will override it.
	*
	* @param logger - The {@link DiagLogger} instance to set as the default logger.
	* @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.
	* @returns `true` if the logger was successfully registered, else `false`
	*/
	setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;
	/**
	*
	* @param logger - The {@link DiagLogger} instance to set as the default logger.
	* @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.
	* @returns `true` if the logger was successfully registered, else `false`
	*/
	setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;
}

/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 *
 * @since 1.0.0
 */
declare class DiagAPI implements DiagLogger, DiagLoggerApi {
	private static _instance?;
	/** Get the singleton instance of the DiagAPI API */
	static instance(): DiagAPI;
	/**
	* Private internal constructor
	* @private
	*/
	private constructor();
	setLogger: DiagLoggerApi['setLogger'];
	/**
	*
	*/
	createComponentLogger: (options: ComponentLoggerOptions) => DiagLogger;
	verbose: DiagLogFunction;
	debug: DiagLogFunction;
	info: DiagLogFunction;
	warn: DiagLogFunction;
	error: DiagLogFunction;
	/**
	* Unregister the global logger and return to Noop
	*/
	disable: () => void;
}

/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 *
 * @since 1.0.0
 */
declare class ContextAPI {
	private static _instance?;
	/** Empty private constructor prevents end users from constructing a new instance of the API */
	private constructor();
	/** Get the singleton instance of the Context API */
	static getInstance(): ContextAPI;
	/**
	* Set the current context manager.
	*
	* @returns true if the context manager was successfully registered, else false
	*/
	setGlobalContextManager(contextManager: ContextManager): boolean;
	/**
	* Get the currently active context
	*/
	active(): Context;
	/**
	* Execute a function with an active context
	*
	* @param context context to be active during function execution
	* @param fn function to execute in a context
	* @param thisArg optional receiver to be used for calling fn
	* @param args optional arguments forwarded to fn
	*/
	with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(context: Context, fn: F, thisArg?: ThisParameterType<F>, ...args: A): ReturnType<F>;
	/**
	* Bind a context to a target function or event emitter
	*
	* @param context context to bind to the event emitter or function. Defaults to the currently active context
	* @param target function or event emitter to bind
	*/
	bind<T>(context: Context, target: T): T;
	private _getContextManager;
	/** Disable and remove the global context manager */
	disable(): void;
}

/**
 * Get a key to uniquely identify a context value
 *
 * @since 1.0.0
 */
declare function createContextKey(description: string): symbol;
/**
 * The root context is used as the default parent context when there is no active context
 *
 * @since 1.0.0
 */
declare const ROOT_CONTEXT: Context;

/**
 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
 * If you want to limit the amount of logging to a specific level or lower use the
 * {@link createLogLevelDiagLogger}
 *
 * @since 1.0.0
 */
declare class DiagConsoleLogger implements DiagLogger {
	constructor();
	/** Log an error scenario that was not expected and caused the requested operation to fail. */
	error: DiagLogFunction;
	/**
	* Log a warning scenario to inform the developer of an issues that should be investigated.
	* The requested operation may or may not have succeeded or completed.
	*/
	warn: DiagLogFunction;
	/**
	* Log a general informational message, this should not affect functionality.
	* This is also the default logging level so this should NOT be used for logging
	* debugging level information.
	*/
	info: DiagLogFunction;
	/**
	* Log a general debug message that can be useful for identifying a failure.
	* Information logged at this level may include diagnostic details that would
	* help identify a failure scenario. Useful scenarios would be to log the execution
	* order of async operations
	*/
	debug: DiagLogFunction;
	/**
	* Log a detailed (verbose) trace level logging that can be used to identify failures
	* where debug level logging would be insufficient, this level of tracing can include
	* input and output parameters and as such may include PII information passing through
	* the API. As such it is recommended that this level of tracing should not be enabled
	* in a production environment.
	*/
	verbose: DiagLogFunction;
}

/**
 * Create a no-op Meter
 *
 * @since 1.3.0
 */
declare function createNoopMeter(): Meter;

/**
 * Proxy tracer provided by the proxy tracer provider
 *
 * @since 1.0.0
 */
declare class ProxyTracer implements Tracer {
	private _provider;
	readonly name: string;
	readonly version?: string | undefined;
	readonly options?: TracerOptions | undefined;
	private _delegate?;
	constructor(_provider: TracerDelegator, name: string, version?: string | undefined, options?: TracerOptions | undefined);
	startSpan(name: string, options?: SpanOptions, context?: Context): Span;
	startActiveSpan<F extends (span: Span) => unknown>(_name: string, _options: F | SpanOptions, _context?: F | Context, _fn?: F): ReturnType<F>;
	/**
	* Try to get a tracer from the proxy tracer provider.
	* If the proxy tracer provider has no delegate, return a noop tracer.
	*/
	private _getTracer;
}
/**
 * @since 1.0.3
 */
interface TracerDelegator {
	getDelegateTracer(name: string, version?: string, options?: TracerOptions): Tracer | undefined;
}

/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 *
 * @since 1.0.0
 */
declare class ProxyTracerProvider implements TracerProvider {
	private _delegate?;
	/**
	* Get a {@link ProxyTracer}
	*/
	getTracer(name: string, version?: string, options?: TracerOptions): Tracer;
	getDelegate(): TracerProvider;
	/**
	* Set the delegate tracer provider
	*/
	setDelegate(delegate: TracerProvider): void;
	getDelegateTracer(name: string, version?: string, options?: TracerOptions): Tracer | undefined;
}

/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 *
 * @since 1.0.0
 */
declare enum SamplingDecision {
	/**
	* `Span.isRecording() === false`, span will not be recorded and all events
	* and attributes will be dropped.
	*/
	NOT_RECORD = 0,
	/**
	* `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
	* MUST NOT be set.
	*/
	RECORD = 1,
	/**
	* `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
	* MUST be set.
	*/
	RECORD_AND_SAMPLED = 2
}
/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling result contains a decision for a {@link Span} and additional
 * attributes the sampler would like to added to the Span.
 *
 * @since 1.0.0
 */
interface SamplingResult {
	/**
	* A sampling decision, refer to {@link SamplingDecision} for details.
	*/
	decision: SamplingDecision;
	/**
	* The list of attributes returned by SamplingResult MUST be immutable.
	* Caller may call {@link Sampler}.shouldSample any number of times and
	* can safely cache the returned value.
	*/
	attributes?: Readonly<SpanAttributes>;
	/**
	* A {@link TraceState} that will be associated with the {@link Span} through
	* the new {@link SpanContext}. Samplers SHOULD return the TraceState from
	* the passed-in {@link Context} if they do not intend to change it. Leaving
	* the value undefined will also leave the TraceState unchanged.
	*/
	traceState?: TraceState;
}

/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * This interface represent a sampler. Sampling is a mechanism to control the
 * noise and overhead introduced by OpenTelemetry by reducing the number of
 * samples of traces collected and sent to the backend.
 *
 * @since 1.0.0
 */
interface Sampler {
	/**
	* Checks whether span needs to be created and tracked.
	*
	* @param context Parent Context which may contain a span.
	* @param traceId of the span to be created. It can be different from the
	*     traceId in the {@link SpanContext}. Typically in situations when the
	*     span to be created starts a new trace.
	* @param spanName of the span to be created.
	* @param spanKind of the span to be created.
	* @param attributes Initial set of SpanAttributes for the Span being constructed.
	* @param links Collection of links that will be associated with the Span to
	*     be created. Typically useful for batch operations.
	* @returns a {@link SamplingResult}.
	*/
	shouldSample(context: Context, traceId: string, spanName: string, spanKind: SpanKind, attributes: SpanAttributes, links: Link[]): SamplingResult;
	/** Returns the sampler name or short description with the configuration. */
	toString(): string;
}

/**
 * @since 1.0.0
 */
declare enum TraceFlags {
	/** Represents no flag set. */
	NONE = 0,
	/** Bit to represent whether trace is sampled in trace flags. */
	SAMPLED = 1
}

/**
 * @since 1.1.0
 */
declare function createTraceState(rawTraceState?: string): TraceState;

/**
 * @since 1.0.0
 */
declare const INVALID_SPANID = "0000000000000000";
/**
 * @since 1.0.0
 */
declare const INVALID_TRACEID = "00000000000000000000000000000000";
/**
 * @since 1.0.0
 */
declare const INVALID_SPAN_CONTEXT: SpanContext;

/**
 * Entrypoint for context API
 * @since 1.0.0
 */
declare const context: ContextAPI;

/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 *
 * @since 1.0.0
 */
declare const diag: DiagAPI;

/**
 * Entrypoint for metrics API
 *
 * @since 1.3.0
 */
declare const metrics: MetricsAPI;

/**
 * Entrypoint for propagation API
 *
 * @since 1.0.0
 */
declare const propagation: PropagationAPI;

/**
 * Entrypoint for trace API
 *
 * @since 1.0.0
 */
declare const trace: TraceAPI;

declare const _default: {
	context: ContextAPI;
	diag: DiagAPI;
	metrics: MetricsAPI;
	propagation: PropagationAPI;
	trace: TraceAPI;
};
//# sourceMappingURL=index.d.ts.map

export { AttributeValue, Attributes, Baggage, BaggageEntry, BaggageEntryMetadata, BatchObservableCallback, BatchObservableResult, ComponentLoggerOptions, Context, ContextAPI, ContextManager, Counter, DiagAPI, DiagConsoleLogger, DiagLogFunction, DiagLogLevel, DiagLogger, DiagLoggerOptions, Exception, Gauge, Histogram, HrTime, INVALID_SPANID, INVALID_SPAN_CONTEXT, INVALID_TRACEID, Link, Meter, MeterOptions, MeterProvider, MetricAdvice, MetricAttributeValue, MetricAttributes, MetricOptions, MetricsAPI, Observable, ObservableCallback, ObservableCounter, ObservableGauge, ObservableResult, ObservableUpDownCounter, PropagationAPI, ProxyTracer, ProxyTracerProvider, ROOT_CONTEXT, Sampler, SamplingDecision, SamplingResult, Span, SpanAttributeValue, SpanAttributes, SpanContext, SpanKind, SpanOptions, SpanStatus, SpanStatusCode, TextMapGetter, TextMapPropagator, TextMapSetter, TimeInput, TraceAPI, TraceFlags, TraceState, Tracer, TracerDelegator, TracerOptions, TracerProvider, UpDownCounter, ValueType, baggageEntryMetadataFromString, context, createContextKey, createNoopMeter, createTraceState, _default as default, defaultTextMapGetter, defaultTextMapSetter, diag, isSpanContextValid, isValidSpanId, isValidTraceId, metrics, propagation, trace };
